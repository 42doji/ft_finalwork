<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>토너먼트 대진표 생성기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col items-center pt-4 md:pt-8 px-2 md:px-4">

<div id="tournamentSectionContainer" class="w-full max-w-5xl mx-auto">
    <div class="p-4 md:p-6 bg-slate-800 rounded-xl shadow-2xl">
        <header class="mb-6 md:mb-8 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-sky-400">토너먼트 대진표 & 퐁 게임</h1>
            <p class="text-slate-400 mt-1 md:mt-2 text-sm md:text-base">참가자 정보를 입력하고 토너먼트를 진행하세요.</p>
        </header>

        <section id="participantInputSection" class="mb-6 md:mb-8 p-4 md:p-6 bg-slate-700 rounded-lg shadow-lg">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 items-start">
                <div>
                    <label for="numParticipants" class="block text-sm font-medium text-sky-300 mb-1">참가자 수:</label>
                    <input type="number" id="numParticipants" name="numParticipants" min="2" max="64" step="1" placeholder="예: 2, 4, 8, 16 (2의 거듭제곱)"
                           class="w-full px-3 py-2 bg-slate-600 border border-slate-500 rounded-md shadow-sm focus:outline-none focus:border-sky-500 focus:ring-1 focus:ring-sky-500 text-slate-100 placeholder-slate-400">
                    <p id="participantErrorMessage" class="text-red-400 text-xs mt-1 h-4"></p>
                </div>
                <div id="participantInputsContainer" class="space-y-2 md:space-y-3 md:mt-0 mt-3 max-h-48 md:max-h-60 overflow-y-auto pr-2">
                    <p class="text-slate-400 text-sm">참가자 수를 먼저 선택하세요.</p>
                </div>
            </div>
            <div class="mt-4 md:mt-6 text-center">
                <button id="generateBracketButton"
                        class="px-6 py-2 md:px-8 md:py-3 bg-sky-600 hover:bg-sky-700 text-white font-semibold rounded-lg shadow-md transition-colors duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled>
                    대진표 생성
                </button>
            </div>
        </section>

        <section id="bracketDisplaySection" class="mt-8 md:mt-10 min-h-[200px] md:min-h-[300px]">
            <h2 class="text-xl md:text-2xl font-semibold text-sky-400 mb-4 md:mb-6 text-center">대진표 결과</h2>
            <div id="bracketContainer" class="flex flex-row space-x-2 md:space-x-6 p-2 md:p-4 overflow-x-auto bg-slate-900/50 ring-1 ring-slate-700 rounded-lg shadow-xl min-h-[150px] md:min-h-[200px]">
                <p class="text-slate-500 text-center w-full self-center text-sm md:text-base">대진표를 생성하려면 위 정보를 입력하세요.</p>
            </div>
            <p id="tournamentWinnerMessage" class="text-center text-sky-300 text-xl font-bold mt-6"></p>
        </section>
    </div>
</div>

<div id="pongGameModal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex flex-col items-center justify-center z-50 p-4">
    <div id="gameInfo" class="retro-font text-white mb-2 text-lg md:text-xl text-center">
        PONG GAME<br>
        <span id="pongPlayer1NameDisplay">Player 1</span>: <span id="pongScore1">0</span> | <span id="pongPlayer2NameDisplay">Player 2</span>: <span id="pongScore2">0</span>
    </div>
    <canvas id="renderCanvas" class="border-2 border-gray-500"></canvas>
    <div id="gameInstructions" class="retro-font text-gray-400 mt-2 text-xs md:text-sm text-center">
        왼쪽 패들: W/S | 오른쪽 패들: ↑/↓<br>
        <span id="pongWinnerMessage" class="text-yellow-400"></span>
    </div>
    <button id="closePongGameButton" class="mt-4 px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md retro-font">게임 종료 & 대진표로</button>
</div>

<section id="pong3DGameSection" class="w-full mt-8 md:mt-10">
    <h2 class="text-xl md:text-2xl font-semibold text-sky-400 mb-4 md:mb-6 text-center">Babylon.js 3D 퐁 게임</h2>
    <div class="ui-container bg-gray-800 p-4 rounded-lg shadow-xl mx-auto max-w-4xl">
        <div id="settingsPanel" class="settings-grid">
            <div class="setting-item">
                <label for="player1Name3D">플레이어 1 이름:</label>
                <input type="text" id="player1Name3D" value="플레이어 1">
            </div>
            <div class="setting-item">
                <label for="player2Name3D">플레이어 2 이름:</label>
                <input type="text" id="player2Name3D" value="플레이어 2">
            </div>
            <div class="setting-item">
                <label for="rounds3D">라운드 수:</label>
                <select id="rounds3D">
                    <option value="1">1</option>
                    <option value="3" selected>3</option>
                    <option value="5">5</option>
                </select>
            </div>
            <div class="setting-item">
                <label for="roundDuration3D">라운드 시간 (초):</label>
                <input type="number" id="roundDuration3D" value="60" min="10">
            </div>
            <div class="setting-item">
                <label for="ballSpeed3D">공 속도:</label>
                <select id="ballSpeed3D">
                    <option value="normal" selected>보통</option>
                    <option value="fast">빠름</option>
                    <option value="veryfast">매우 빠름</option>
                </select>
            </div>
        </div>
        <div class="game-controls">
            <button id="startGameButton3D">게임 시작</button>
            <button id="quitGameButton3D" style="display: none; background-color: #e53e3e;">게임 종료</button>
        </div>
        <div class="game-info">
            <div id="scorePlayer1Display3D">플레이어 1: 0</div>
            <div id="timerDisplay3D">시간: 00:00</div>
            <div id="scorePlayer2Display3D">플레이어 2: 0</div>
        </div>
        <div id="roundInfoDisplay3D" class="message-area">라운드: 0 / 0</div>
        <div id="messageArea3D" class="message-area">설정을 선택하고 게임을 시작하세요.</div>
    </div>
    <canvas id="renderCanvasPong3D" class="w-full block mx-auto max-w-4xl h-[70vh] mt-4 rounded-lg shadow-xl"></canvas>

    <script type="module">
        // Babylon.js and game logic (user-provided script - unchanged)
        // ... (The existing 3D Pong game inline script content remains here) ...
        // 예시: UI 요소 가져오기
        const canvas3D = document.getElementById('renderCanvasPong3D');
        const engine3D = new BABYLON.Engine(canvas3D, true);

        const player1NameInput3D = document.getElementById('player1Name3D');
        const player2NameInput3D = document.getElementById('player2Name3D');
        const roundsSelect3D = document.getElementById('rounds3D');
        const roundDurationInput3D = document.getElementById('roundDuration3D');
        const ballSpeedSelect3D = document.getElementById('ballSpeed3D');
        const startGameButton3D_el = document.getElementById('startGameButton3D');
        const quitGameButton3D_el = document.getElementById('quitGameButton3D');
        const scorePlayer1Display3D_el = document.getElementById('scorePlayer1Display3D');
        const scorePlayer2Display3D_el = document.getElementById('scorePlayer2Display3D');
        const timerDisplay3D_el = document.getElementById('timerDisplay3D');
        const messageArea3D_el = document.getElementById('messageArea3D');
        const roundInfoDisplay3D_el = document.getElementById('roundInfoDisplay3D');

        // Game state constants
        const GameState3D = { LOBBY: 0, COUNTDOWN: 1, PLAYING: 2, ROUND_OVER: 3, GAME_OVER: 4 };

        // Game variables
        let scene3D;
        let camera3D;
        let player1Paddle3D, player2Paddle3D;
        let ball3D;
        let topWall3D, bottomWall3D;
        let ground3D;

        let p1Name3D = "플레이어 1";
        let p2Name3D = "플레이어 2";
        let scoreP1_3D = 0;
        let scoreP2_3D = 0;
        let currentRound3D_val = 0;
        let totalRounds3D_val = 3;
        let roundTimeLimit3D_val = 60;
        let currentRoundTime3D_val = 0;
        let ballSpeedMultiplier3D_val = 1.0;
        let gameState3D_val = GameState3D.LOBBY;

        const PADDLE_HEIGHT_3D = 4;
        const PADDLE_WIDTH_3D = 0.5;
        const PADDLE_DEPTH_3D = 0.5;
        const BALL_RADIUS_3D = 0.3;
        const COURT_WIDTH_3D = 20;
        const COURT_HEIGHT_3D = 12;
        const COURT_DEPTH_3D = 10; // This was not used for ground height previously, but good for reference
        const PADDLE_SPEED_3D = 0.3;
        let BASE_BALL_SPEED_X_3D = 0.15; // Base speed, adjusted by multiplier

        let ballVelocity3D = new BABYLON.Vector3(0, 0, 0);
        let inputMap3D = {};

        let roundTimerInterval3D;
        let shadowGenerator3D;

        function createScene3D_func() {
            scene3D = new BABYLON.Scene(engine3D);
            scene3D.clearColor = new BABYLON.Color3(0.05, 0.05, 0.1); // Dark blue-ish background

            // Camera
            camera3D = new BABYLON.UniversalCamera("gameCamera3D", new BABYLON.Vector3(0, 5, -22), scene3D); // Positioned further back and slightly up
            camera3D.setTarget(new BABYLON.Vector3(0, 0, 0)); // Looks at the center of the court
            camera3D.fov = 0.7; // Field of View

            // Lighting
            const light3D_scene = new BABYLON.HemisphericLight("light1_3D_scene", new BABYLON.Vector3(0, 1, 0), scene3D);
            light3D_scene.intensity = 0.6;

            const dirLight3D_scene = new BABYLON.DirectionalLight("dirLight_3D_scene", new BABYLON.Vector3(-0.5, -1, -1), scene3D);
            dirLight3D_scene.intensity = 0.7;
            dirLight3D_scene.position = new BABYLON.Vector3(10, 20, 20); // Positioned to cast shadows

            // Materials
            const paddleMaterial1_3D = new BABYLON.StandardMaterial("paddleMat1_3D", scene3D);
            paddleMaterial1_3D.diffuseColor = new BABYLON.Color3(0.3, 0.6, 0.9); // Blueish
            paddleMaterial1_3D.emissiveColor = new BABYLON.Color3(0.1, 0.25, 0.4); // Slight glow

            player1Paddle3D = BABYLON.MeshBuilder.CreateBox("player1Paddle3D", { height: PADDLE_HEIGHT_3D, width: PADDLE_WIDTH_3D, depth: PADDLE_DEPTH_3D }, scene3D);
            player1Paddle3D.material = paddleMaterial1_3D;
            player1Paddle3D.position = new BABYLON.Vector3(-COURT_WIDTH_3D / 2 + 1, 0, 0); // Positioned left

            const paddleMaterial2_3D = new BABYLON.StandardMaterial("paddleMat2_3D", scene3D);
            paddleMaterial2_3D.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0.4); // Reddish
            paddleMaterial2_3D.emissiveColor = new BABYLON.Color3(0.4, 0.15, 0.15);

            player2Paddle3D = BABYLON.MeshBuilder.CreateBox("player2Paddle3D", { height: PADDLE_HEIGHT_3D, width: PADDLE_WIDTH_3D, depth: PADDLE_DEPTH_3D }, scene3D);
            player2Paddle3D.material = paddleMaterial2_3D;
            player2Paddle3D.position = new BABYLON.Vector3(COURT_WIDTH_3D / 2 - 1, 0, 0); // Positioned right

            const ballMaterial3D = new BABYLON.StandardMaterial("ballMat3D", scene3D);
            ballMaterial3D.diffuseColor = new BABYLON.Color3(1, 1, 0.3); // Yellowish
            ballMaterial3D.emissiveColor = new BABYLON.Color3(0.6, 0.6, 0.1);

            ball3D = BABYLON.MeshBuilder.CreateSphere("ball3D", { diameter: BALL_RADIUS_3D * 2, segments: 16 }, scene3D);
            ball3D.material = ballMaterial3D;
            ball3D.position = new BABYLON.Vector3(0, 0, 0); // Starts at center

            // Walls (visual boundaries)
            const wallMaterial3D = new BABYLON.StandardMaterial("wallMat3D", scene3D);
            wallMaterial3D.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.7); // Light grey
            wallMaterial3D.alpha = 0.6; // Semi-transparent

            topWall3D = BABYLON.MeshBuilder.CreateBox("topWall3D", {width: COURT_WIDTH_3D, height: 0.3, depth: PADDLE_DEPTH_3D}, scene3D);
            topWall3D.position = new BABYLON.Vector3(0, COURT_HEIGHT_3D / 2 + BALL_RADIUS_3D, 0);
            topWall3D.material = wallMaterial3D;

            bottomWall3D = BABYLON.MeshBuilder.CreateBox("bottomWall3D", {width: COURT_WIDTH_3D, height: 0.3, depth: PADDLE_DEPTH_3D}, scene3D);
            bottomWall3D.position = new BABYLON.Vector3(0, -COURT_HEIGHT_3D / 2 - BALL_RADIUS_3D, 0);
            bottomWall3D.material = wallMaterial3D;

            // Ground
            ground3D = BABYLON.MeshBuilder.CreateGround("ground3D", {width: COURT_WIDTH_3D, height: COURT_DEPTH_3D * 1.5}, scene3D); // Ground is wider than deep
            ground3D.position.y = -COURT_HEIGHT_3D / 2 - BALL_RADIUS_3D - 0.2; // Positioned below the bottom boundary
            const gridMaterial3D = new BABYLON.GridMaterial("gridMat3D", scene3D);
            gridMaterial3D.mainColor = new BABYLON.Color3(0.2, 0.2, 0.3);
            gridMaterial3D.lineColor = new BABYLON.Color3(0.5, 0.5, 0.7);
            ground3D.material = gridMaterial3D;
            ground3D.receiveShadows = true;

            // Shadows
            shadowGenerator3D = new BABYLON.ShadowGenerator(1024, dirLight3D_scene);
            shadowGenerator3D.addShadowCaster(ball3D);
            shadowGenerator3D.addShadowCaster(player1Paddle3D);
            shadowGenerator3D.addShadowCaster(player2Paddle3D);
            // shadowGenerator3D.useBlurExponentialShadowMap = true;
            // shadowGenerator3D.useKernelBlur = true;
            // shadowGenerator3D.blurKernel = 32;

            return scene3D;
        }


        function setupInput3D_func() {
            if (!scene3D) return;
            scene3D.actionManager = new BABYLON.ActionManager(scene3D);
            scene3D.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt) => {
                inputMap3D[evt.sourceEvent.key.toLowerCase()] = true;
                // Prevent page scroll for game keys
                if (["arrowup", "arrowdown", "w", "s"].includes(evt.sourceEvent.key.toLowerCase())) {
                    evt.sourceEvent.preventDefault();
                }
            }));
            scene3D.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, (evt) => {
                inputMap3D[evt.sourceEvent.key.toLowerCase()] = false;
                if (["arrowup", "arrowdown", "w", "s"].includes(evt.sourceEvent.key.toLowerCase())) {
                    evt.sourceEvent.preventDefault();
                }
            }));
        }

        function updatePaddleMovement3D_func() {
            const paddleMinY = -COURT_HEIGHT_3D / 2 + PADDLE_HEIGHT_3D / 2;
            const paddleMaxY = COURT_HEIGHT_3D / 2 - PADDLE_HEIGHT_3D / 2;

            if (inputMap3D["w"]) player1Paddle3D.position.y = Math.min(paddleMaxY, player1Paddle3D.position.y + PADDLE_SPEED_3D);
            if (inputMap3D["s"]) player1Paddle3D.position.y = Math.max(paddleMinY, player1Paddle3D.position.y - PADDLE_SPEED_3D);
            if (inputMap3D["arrowup"]) player2Paddle3D.position.y = Math.min(paddleMaxY, player2Paddle3D.position.y + PADDLE_SPEED_3D);
            if (inputMap3D["arrowdown"]) player2Paddle3D.position.y = Math.max(paddleMinY, player2Paddle3D.position.y - PADDLE_SPEED_3D);
        }

        function updateBallMovement3D_func() {
            if (gameState3D_val !== GameState3D.PLAYING || !ball3D) return;

            ball3D.position.addInPlace(ballVelocity3D);

            // Wall collisions (top/bottom)
            if (ball3D.position.y + BALL_RADIUS_3D > COURT_HEIGHT_3D / 2 || ball3D.position.y - BALL_RADIUS_3D < -COURT_HEIGHT_3D / 2) {
                ballVelocity3D.y *= -1; // Reverse Y velocity
                // Clamp ball position to prevent sticking
                ball3D.position.y = Math.max(-COURT_HEIGHT_3D/2 + BALL_RADIUS_3D, Math.min(COURT_HEIGHT_3D/2 - BALL_RADIUS_3D, ball3D.position.y));
            }

            // Paddle collisions
            if (ball3D.intersectsMesh(player1Paddle3D, false) && ballVelocity3D.x < 0) {
                ballVelocity3D.x *= -1.05; // Reverse X and slightly increase speed
                ballVelocity3D.y += (ball3D.position.y - player1Paddle3D.position.y) * 0.12; // Add some spin based on impact point
                ball3D.position.x = player1Paddle3D.position.x + PADDLE_WIDTH_3D / 2 + BALL_RADIUS_3D + 0.01; // Prevent sticking
            }
            if (ball3D.intersectsMesh(player2Paddle3D, false) && ballVelocity3D.x > 0) {
                ballVelocity3D.x *= -1.05;
                ballVelocity3D.y += (ball3D.position.y - player2Paddle3D.position.y) * 0.12;
                ball3D.position.x = player2Paddle3D.position.x - PADDLE_WIDTH_3D / 2 - BALL_RADIUS_3D - 0.01;
            }

            // Scoring
            if (ball3D.position.x < -COURT_WIDTH_3D / 2 - BALL_RADIUS_3D * 2) { // Increased scoring threshold
                scoreP2_3D++;
                handleScore3D_func(p2Name3D);
            } else if (ball3D.position.x > COURT_WIDTH_3D / 2 + BALL_RADIUS_3D * 2) {
                scoreP1_3D++;
                handleScore3D_func(p1Name3D);
            }
        }

        function handleScore3D_func(scoringPlayerName) {
            updateScoreboard3D_func();
            displayMessage3D_func(`${scoringPlayerName} 득점!`, 2000);
            resetBallAndState3D_func(GameState3D.COUNTDOWN); // Go to countdown after score
        }

        function resetBallAndState3D_func(nextState = GameState3D.PLAYING) {
            if (!ball3D) return;
            // Reset ball position to center, with slight random Y
            ball3D.position.set(0, Math.random() * (COURT_HEIGHT_3D - PADDLE_HEIGHT_3D) - (COURT_HEIGHT_3D - PADDLE_HEIGHT_3D)/2 , 0);

            // Random initial angle for the ball
            let angle = (Math.random() * Math.PI / 2.5 - Math.PI / 5) + (Math.random() < 0.5 ? 0 : Math.PI); // More varied angle
            const speed = BASE_BALL_SPEED_X_3D * ballSpeedMultiplier3D_val;
            ballVelocity3D.set(speed * Math.cos(angle), speed * Math.sin(angle) * 0.8 , 0); // Z velocity is 0 for 2D plane movement

            setGameState3D_func(nextState);
        }


        function updateScoreboard3D_func() {
            if(scorePlayer1Display3D_el) scorePlayer1Display3D_el.textContent = `${p1Name3D}: ${scoreP1_3D}`;
            if(scorePlayer2Display3D_el) scorePlayer2Display3D_el.textContent = `${p2Name3D}: ${scoreP2_3D}`;
            if(roundInfoDisplay3D_el) roundInfoDisplay3D_el.textContent = `라운드: ${currentRound3D_val} / ${totalRounds3D_val}`;
        }

        function updateTimerDisplay3D_func() {
            const minutes = Math.floor(currentRoundTime3D_val / 60);
            const seconds = currentRoundTime3D_val % 60;
            if(timerDisplay3D_el) timerDisplay3D_el.textContent = `시간: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function displayMessage3D_func(msg, duration = 0) {
            if(messageArea3D_el) messageArea3D_el.textContent = msg;
            if (duration > 0) {
                setTimeout(() => {
                    // Clear message only if it hasn't been replaced by a newer one
                    if (messageArea3D_el && messageArea3D_el.textContent === msg) {
                        messageArea3D_el.textContent = (gameState3D_val >= GameState3D.GAME_OVER) ? "새 게임을 시작하려면 설정을 조정하고 시작 버튼을 누르세요." : "";
                    }
                }, duration);
            }
        }

        function setGameState3D_func(newState) {
            gameState3D_val = newState;
            const settingsPanel_el = document.getElementById('settingsPanel'); // Get it here as it might not exist on first call

            if(quitGameButton3D_el) quitGameButton3D_el.style.display = (newState !== GameState3D.LOBBY && newState !== GameState3D.GAME_OVER) ? 'inline-block' : 'none';
            if(startGameButton3D_el) startGameButton3D_el.style.display = (newState === GameState3D.LOBBY || newState === GameState3D.GAME_OVER) ? 'inline-block' : 'none';


            if(settingsPanel_el) settingsPanel_el.style.display = (newState === GameState3D.LOBBY || newState === GameState3D.GAME_OVER) ? 'grid' : 'none';


            switch (gameState3D_val) {
                case GameState3D.LOBBY:
                    displayMessage3D_func("설정을 선택하고 게임을 시작하세요.");
                    if (roundTimerInterval3D) clearInterval(roundTimerInterval3D);
                    inputMap3D = {}; // Clear input map
                    resetGameStats3D_func(); // Reset scores
                    updateScoreboard3D_func();
                    updateTimerDisplay3D_func(); // Reset timer display
                    if(roundInfoDisplay3D_el) roundInfoDisplay3D_el.textContent = `라운드: 0 / ${totalRounds3D_val}`;
                    if(ball3D) ball3D.isVisible = false; // Hide ball
                    // Reset paddle positions
                    if(player1Paddle3D) player1Paddle3D.position.y = 0;
                    if(player2Paddle3D) player2Paddle3D.position.y = 0;
                    break;
                case GameState3D.COUNTDOWN:
                    if(ball3D) ball3D.isVisible = true; // Show ball
                    displayMessage3D_func("준비...", 1000);
                    setTimeout(() => displayMessage3D_func("3", 1000), 1000);
                    setTimeout(() => displayMessage3D_func("2", 1000), 2000);
                    setTimeout(() => displayMessage3D_func("1", 1000), 3000);
                    setTimeout(() => {
                        if(gameState3D_val === GameState3D.COUNTDOWN) { // Ensure state hasn't changed (e.g. quit)
                            displayMessage3D_func("시작!", 1000);
                            setGameState3D_func(GameState3D.PLAYING);
                        }
                    }, 4000);
                    break;
                case GameState3D.PLAYING:
                    startRoundTimer3D_func();
                    break;
                case GameState3D.ROUND_OVER:
                    clearInterval(roundTimerInterval3D);
                    // Wait a bit before starting new round or ending game
                    setTimeout(() => {
                        if(gameState3D_val === GameState3D.ROUND_OVER) { // Check state again
                            if (currentRound3D_val >= totalRounds3D_val && totalRounds3D_val > 0) {
                                setGameState3D_func(GameState3D.GAME_OVER);
                            } else {
                                startNewRound3D_func();
                            }
                        }
                    }, 3000); // 3 second pause
                    break;
                case GameState3D.GAME_OVER:
                    clearInterval(roundTimerInterval3D);
                    determineGameWinner3D_func();
                    break;
            }
        }


        function startGameTrigger3D() {
            if (gameState3D_val === GameState3D.LOBBY || gameState3D_val === GameState3D.GAME_OVER) {
                // Update game settings from UI
                p1Name3D = player1NameInput3D.value || "플레이어 1";
                p2Name3D = player2NameInput3D.value || "플레이어 2";
                totalRounds3D_val = parseInt(roundsSelect3D.value);
                roundTimeLimit3D_val = parseInt(roundDurationInput3D.value) || 60; // Default 60s
                const speedSetting = ballSpeedSelect3D.value;
                if (speedSetting === "fast") ballSpeedMultiplier3D_val = 1.5;
                else if (speedSetting === "veryfast") ballSpeedMultiplier3D_val = 2.0;
                else ballSpeedMultiplier3D_val = 1.0; // Normal

                resetGameStats3D_func(); // Reset scores for a new game
                currentRound3D_val = 0; // Reset round count
                updateScoreboard3D_func();
                startNewRound3D_func();
            }
        }

        function resetGameStats3D_func() {
            scoreP1_3D = 0;
            scoreP2_3D = 0;
        }

        function startNewRound3D_func() {
            currentRound3D_val++;
            if (currentRound3D_val > totalRounds3D_val && totalRounds3D_val > 0) {
                setGameState3D_func(GameState3D.GAME_OVER);
                return;
            }
            displayMessage3D_func(`라운드 ${currentRound3D_val} 시작!`, 2000);
            if(roundInfoDisplay3D_el) roundInfoDisplay3D_el.textContent = `라운드: ${currentRound3D_val} / ${totalRounds3D_val}`;
            currentRoundTime3D_val = roundTimeLimit3D_val; // Reset round timer
            updateTimerDisplay3D_func();
            // Reset paddle positions for new round
            if(player1Paddle3D) player1Paddle3D.position.y = 0;
            if(player2Paddle3D) player2Paddle3D.position.y = 0;
            resetBallAndState3D_func(GameState3D.COUNTDOWN); // Start with countdown
        }

        function startRoundTimer3D_func() {
            clearInterval(roundTimerInterval3D); // Clear any existing timer
            roundTimerInterval3D = setInterval(() => {
                if (gameState3D_val === GameState3D.PLAYING) {
                    currentRoundTime3D_val--;
                    updateTimerDisplay3D_func();
                    if (currentRoundTime3D_val <= 0) {
                        endRound3D_func(); // Time's up
                    }
                }
            }, 1000);
        }

        function endRound3D_func() {
            setGameState3D_func(GameState3D.ROUND_OVER);
            let roundWinnerMsg = "시간 종료! ";
            if (scoreP1_3D > scoreP2_3D) roundWinnerMsg += `${p1Name3D} 승리!`;
            else if (scoreP2_3D > scoreP1_3D) roundWinnerMsg += `${p2Name3D} 승리!`;
            else roundWinnerMsg += "무승부!";
            displayMessage3D_func(`라운드 ${currentRound3D_val} - ${roundWinnerMsg}`, 3000);
        }

        function determineGameWinner3D_func() {
            let winnerMsg;
            if (scoreP1_3D > scoreP2_3D) winnerMsg = `${p1Name3D}! (총점 ${scoreP1_3D} vs ${scoreP2_3D})`;
            else if (scoreP2_3D > scoreP1_3D) winnerMsg = `${p2Name3D}! (총점 ${scoreP2_3D} vs ${scoreP1_3D})`;
            else winnerMsg = `무승부! (총점 ${scoreP1_3D} vs ${scoreP2_3D})`;
            displayMessage3D_func(`최종 승리: ${winnerMsg}`, 5000);
            // Transition back to lobby after showing winner
            setTimeout(() => {
                if(gameState3D_val === GameState3D.GAME_OVER) setGameState3D_func(GameState3D.LOBBY);
            }, 5000);
        }


        function initGame3D_func() {
            if (!scene3D) { // Create scene only once
                scene3D = createScene3D_func();
                setupInput3D_func(); // Setup input after scene is created
            }

            // Ensure render loop is started only once
            if (!engine3D.activeRenderLoops || engine3D.activeRenderLoops.length === 0) {
                engine3D.runRenderLoop(() => {
                    if (gameState3D_val === GameState3D.PLAYING) {
                        updatePaddleMovement3D_func();
                        updateBallMovement3D_func();
                    }
                    if (scene3D) { // Ensure scene exists before rendering
                        scene3D.render();
                    }
                });
            }
            // Handle window resize
            window.addEventListener('resize', () => {
                engine3D.resize();
            });
        }


        // Event Listeners for UI
        if(startGameButton3D_el) {
            startGameButton3D_el.addEventListener('click', () => {
                if (gameState3D_val === GameState3D.LOBBY || gameState3D_val === GameState3D.GAME_OVER) {
                    if (!scene3D && canvas3D && canvas3D.offsetParent !== null) { // Check if canvas is visible
                        initGame3D_func(); // Initialize if not already
                    } else if (scene3D) { // If scene exists, just ensure it's ready
                        engine3D.resize(); // Good to call resize in case layout changed
                    }
                    startGameTrigger3D();
                }
            });
        }

        if(quitGameButton3D_el) {
            quitGameButton3D_el.addEventListener('click', () => {
                if (gameState3D_val !== GameState3D.LOBBY && gameState3D_val !== GameState3D.GAME_OVER) {
                    if (roundTimerInterval3D) clearInterval(roundTimerInterval3D);
                    displayMessage3D_func("게임이 종료되었습니다. 설정을 다시 선택하세요.", 3000);
                    setGameState3D_func(GameState3D.LOBBY);
                }
            });
        }

        // Initial setup on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Set initial values from UI (in case they are pre-filled)
            p1Name3D = player1NameInput3D.value || "플레이어 1";
            p2Name3D = player2NameInput3D.value || "플레이어 2";
            totalRounds3D_val = parseInt(roundsSelect3D.value);
            roundTimeLimit3D_val = parseInt(roundDurationInput3D.value);

            setGameState3D_func(GameState3D.LOBBY); // Start in lobby state

            // Lazy initialization of Babylon scene when it might be visible
            // This is a simple check; IntersectionObserver could be more robust
            if (canvas3D && canvas3D.offsetParent !== null) { // Check if canvas is visible
                initGame3D_func();
            }
        });
    </script>
</section>

<footer class="text-center py-6 md:py-8 text-slate-500 text-xs md:text-sm">
    Tailwind CSS & TypeScript Tournament Bracket Generator
</footer>

<script src="dist/app.js"></script>
</body>
</html>
